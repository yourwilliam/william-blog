---
layout: post
title: java移位详解
description: "java移位详解"
modified: 2012-12-10
category: articles
tags: [java,j2se]
comments: true
share: true
---

#### java移位详解

<< 左移位  >>带符号右移位  >>>无符号右移

##### 移位的类型转换
* 移位运算时，byte、short和char类型移位后的结果会变成int类型。
* int和上述三种类型移位时，规定实际的移动次数是移动次数和32的余数
* 移动long型数值时，规定实际移动的次数是移动次数和64的余数

##### 移位方式
* << ： 按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，地位的空位补空
* >> ： 按二进制形式把所有的数字向右移动对应的位数，地位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1。

#### 位数操作

##### +=、-=、&= 此类操作符和 +、-、/、&的区别
例子：

	double d = 23.234D;
	d/=5;    //d = 4.8468
	d = d/5  //d = 4.8468

	byte number = -23;
	number = number & 0xf0; //number=-32
	(number & 0xf0) = 224  // 它为int型

此处0xf0为无符号整形，所以number也将转换为无符号整形进行计算。

`byte number = -23; (number & 0xF0)此时这个字段为int类型，也就是说number被默认转换为了0xF0的类型，而int默认为无符号类型，所以number为补码：

源码： 10010111    反码：11101000   补码：11101001

转换为int 类型：  11111111 11111111 11111111 11101001

0xF0： 0000 ...... 11110000

相与： 0000 ...... 11100000 (224)

注意此处是进行的直接用补码和0xF0相与。

而如果使用number &= 0xF0, 则此时number依然为byte类型，且根据前面的为带符号的，而且此时为将number转化为0xF0类型进行运算，运算之后再强制转化为原类型。

结果 ： 11100000  (补)
值 ： 11011111    原： 10100000  (-32)












